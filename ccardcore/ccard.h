// I decided to go with a unified header file for all system calls
//
// this is the only header file you need for cleanccard system calls
//
// there may be other headers in the project, but they should only be used
//   when building the kernel module
//
// all internal hardware operations (deployment, magnetorquer switching, etc)
//   are handled on separate threads
// all status querying operations don't need to be concerned with this, status
//   will never be on a blocked thread

// preprocessor macros (along with the endif at the bottom) are used to prevent
//   including the same file twice in projects with lots of header files

#include<linux/types.h>
#include<linux/i2c.h>

#ifndef _cleanheader
#define _cleanheader

// enum for values representing the DSA (deployable solar array) state
enum dsa_state {
	stowed = 0b0000,    // 0

	// values that could be returned by getDSAState but should
	//   not be used in setDSAState
	releasing = 0b0001, // 1
	deploying = 0b0100, // 4

	// acceptable values to use with setDSAState
	released = 0b0010,  // 2
	deployed = 0b1010,  // 10

	// error conditions
	timeout = 0b1011,   // 9
	// used if a requested DSA state is attempting to access
	//   a non-existent DSA
	num_error = 0b1100   // 12
};


// there's actually a really cool basis for these values
// so I designed the magnetorquer circuit around this H-Bridge
//   IC (integrated circuit)(for more information on what an
//     H-Bridge is, see this wikipedia article: https://en.wikipedia.org/wiki/H_bridge)
//   http://www.rohm.com/web/global/datasheet/BD6230F/bd623x-e - IC datasheet
// the advantage of using this H-Bridge IC is that it allows the
//   direction of current through the magnetoruqers to be reversed,
//   which in turn reverses the polarity of the magnetic field generated
//   by the magnetorquer
// however, when dealing with an inductor, you have to be concerned with
//   the back emf generated by a change in current
// well when you switch from off to on, on to off, or especially when you
//   change directions, you create a large back emf
// in order to prevent a large voltage damaging the circuitry, the magnetorquer
//   system calls will put the device in a transistioning state when switching
//   from on to off or from reverse to forward, which effectively isolates the
//   magnetorquer circuit into a loop separate from the rest of the circuits so
//   that the magnetic field can decay and release its energy as heat through
//   the 9.1ohm resistor and wire
// the cool thing here is that that state is activated by sending a forward and
//   reverse signal at the same time, which is exactly how it's represented here

// enum for values representing the magnetorquer state
enum mt_state {
	off = 0b00,          // 0
	forward = 0b01,      // 1
	reverse = 0b10,      // 2

	// this is effectively "brake", and lets the magnetic
	//   field taht was built up decay
	// this will automatically be set by the internal implementation
	//   when switching states, so you shouldn't need to set this
	//   condition manually
	// however, setMagnetorquer state won't complain if you pass this
	//   in as a value, as it could be useful for debugging the hardware
	transitioning = 0b11 // 3
};

#define ccard_3v3_gpio 102
#define ccard_5v0_gpio 103
// 1 = on, 0 = off
// flags: 0 = normal, !0 = emergency shutoff (ignore semaphore)
void set_3v3_state(u8 state, s8 flags);
void set_5v0_state(u8 state, s8 flags);

// returns a struct containing the i2c infomation for the GPIO expanders
// these are implemented by their respective controllers
struct i2c_client *dsa_expdr(void);
struct i2c_client *mt_expdr(void);

// this function initializes the DSA hardware so that it is ready for release
//   and/or deploy operations
// the parameter is passed by the i2c driver and contains the i2c adapter
// returns 0 on success and -1 on failure
s8 init_dsa(void);

// this function initializes the magnetorquer hardware so that it is ready
// for forward or reverse operations
// the paramter is the i2c adapter for the client hardware
// returns 0 on success and -1 on failure
s8 init_mt(void);

// starts the i2c driver
s8 ccard_init_i2c(void);
// ends the i2c driver
void ccard_cleanup_i2c(void);

// cleans up data for the DSAs and turns off power
void cleanup_dsa(void);

// clenas up data for the magnetoruqers and safely switches them off
void cleanup_mt(void);


// these are used as the maximum time power should be on for the corresponding
//   operation
// the actual time power is on will always be less than or equal to the timeout
//   maximum, since if the GPIO's indicate success before the timeout, power will
//   be cut automatically
// these values can be overriden by the user through the corresponding function,
//   which allows these values (there are non-const values in the implementation that hold
//   the user-selected values) to be altered without recompiling the kernel module
// values here are listed in seconds
#define ccard_rel_timeout 50
#define ccard_dep_timeout 10

// these functions allow the user to override the constants set above with
//   a runtime-configurable value, removing the need to recompile
// desireTimeout is a value in seconds
void set_usr_rel_timeout(u8 desired_timeout);
void set_usr_dep_timeout(u8 desired_timeout);



// this function returns an enum value representing the current state of
//   DSA <dsaNumber>
// this is a relatively instantaneous function, and simply queries the
//   GPIO expander connected to the DSAs and checks the GPIO inputs
//   from the DSA sense cable
// Oh yeah thats another improvement, the DSA sense pins actually route
//   to the GPIO expander, rather than the intrepid's GPIOs
//   this is made possible by adding a seconding GPIO expander for the
//   magnetorquers, freeing up exactly the right number of GPIOs
enum dsa_state get_dsa_state(u8 dsa);

// this function returns an enum value representing the current state of
//   magnetorquer <mtNumber>
// this is also relatively instantaneous, but you can run into issues
//   if you're not careful because the transitioning state, while
//   very short, may be the current state of the magnetorquer if you
//   query this frequently, so just be aware of that
enum mt_state get_mt_state(u8 mt);




// as it implies, this function attempts to set DSA <dsaNumber> to
//   the state indicated by <desiredState>
// if that fails because of a hardware issue, i2c access problem,
//   or because <desiredState> indicated an impossible transition
//   (such as transitioning from released to stowed, which must be
//   done manually, or asking to transition to releasing or deploying,
//   which are intermediates and do not represent a discrete state),
//   then this function will halt and return -1, indicating
//   an error
// however, you'll notice that a transition from stowed to released is
//   not recognized as an impossible transition
// so what happens when you indicated a transition from stowed to released?
// well the function will recognize it as a possible error, and will
//   log a warning, as well as return 3, indicating a warning condition,
//   but the operation will still be carried out
// if an operation is acceptable and no warnings or errors occured, this
//   will return 0 to indicate a good value for desiredState
// NOTE: this DOES NOT mean that the DSA state was actually changed, just
//   that it was valid input and has been passed to a background thread
//   to execute the actual hardware change
// Normally, I would add a function pointer as an input to be called when the
//   operation finishes, but because this is a kernel module, not only
//   would that be insecure, it would also lead to insanely difficult bugs
//   to diagnose and crazy reboots, so the recommended way to check the DSA
//   state is to query the getDSAState(dsaNumber) function periodically
//
// desired state should be either <released> or <deployed>
s8 set_dsa_state(u8 dsa, enum dsa_state desired_state);

// this function sets magnetorquer <mtNumber> to the desired state indicated
//   by <desiredState>
// returns 0 if the passed in state was acceptable (which it will always be if
//   you use a value from the MTState enum} and the system has successfully
//   transitioned to that state
// this function, unlike setDSAState, executes hardware changes on a the calling
//   thread, so it does not requires the user to query getMagnetorquer state,
//   though this function will take a longer period of time to return,
//   unlike the DSA function
// <transitioning> is an acceptable state here as it is useful when debugging
//   the hardware, though it is unnecessary to do in normal operation as the
//   implementation already handles switching to that as an intermediate state
// setting the state to transitioning allows for a store magnetic field to
//   discharge as it created a closed, short circuit across the 9.1ohm resistor,
//   the magnetorquer coil, and an isolated branch of the H-bridge IC
s8 set_mt_state(u8 mt, enum mt_state desired_state);


#endif

















