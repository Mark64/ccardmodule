// I decided to go with a unified header file for all calls, which proved
//   very useful when it came to debugging

// preprocessor macros (along with the endif at the bottom) are used to prevent
//   including the same file twice in projects with lots of header files
// by Mark Hill

#include<linux/types.h>
#include<linux/i2c.h>

#ifndef _cleanheader
#define _cleanheader

// enum for values representing the DSA (deployable solar array) state
enum dsa_state {
	stowed = 0b0000,    // 0

	// values that could be returned by getDSAState but should
	//   not be used in setDSAState
	releasing = 0b0001, // 1
	deploying = 0b0100, // 4

	// acceptable values to use with setDSAState
	released = 0b0010,  // 2
	deployed = 0b1010,  // 10
};


// so I designed the magnetorquer circuit around this H-Bridge
//   IC (integrated circuit)(for more information on what an
//     H-Bridge is, see this wikipedia article: https://en.wikipedia.org/wiki/H_bridge)
//   http://www.rohm.com/web/global/datasheet/BD6230F/bd623x-e - IC datasheet
// the advantage of using this H-Bridge IC is that it allows the
//   direction of current through the magnetoruqers to be reversed,
//   which in turn reverses the polarity of the magnetic field generated
//   by the magnetorquer
// however, when dealing with an inductor, you have to be concerned with
//   the back emf generated by a change in current
// when you switch from off to on, on to off, or especially when you
//   change directions, you create a large back emf
// in order to prevent a large voltage damaging the circuitry, the magnetorquer
//   function calls will put the device in a transistioning state when switching
//   from on to off or from reverse to forward, which effectively isolates the
//   magnetorquer circuit into a loop separate from the rest of the circuits so
//   that the magnetic field can decay and release its energy as heat through
//   the 9.1ohm resistor and wire

// enum for values representing the magnetorquer state
enum mt_state {
	off = 0b00,          // 0
	forward = 0b01,      // 1
	reverse = 0b10,      // 2

	// this will automatically be set by the internal implementation
	//   when switching states, so you shouldn't need to set this
	//   condition manually
	// however, setMagnetorquer state won't complain if you pass this
	//   in as a value, as it could be useful for debugging the hardware
	transitioning = 0b11 // 3
};

// structure representing a 3d vector with integer components
struct ccard_vec3int {
	s32 x;
	s32 y;
	s32 z;
};


// 1 = on, 0 = off
// flags: 0 = normal, !0 = emergency shutoff (ignore semaphore)
// the dsas are the only users of the 3v3 source
void set_dsa_pwr(u8 state, s8 flags);
// the main 5v0 source for all components
void set_5v0_pwr(u8 state, s8 flags);

// returns a struct pointer containing the i2c infomation for the GPIO
//   expanders
// these are implemented by their respective controllers
struct i2c_client *dsa_expdr(void);
struct i2c_client *mt_expdr(void);

// this function initializes the DSA hardware so that it is ready for release
//   and/or deploy operations
// returns 0 on success and -1 on failure
s8 init_dsa(void);

// this function initializes the magnetorquer hardware so that it is ready
// for forward or reverse operations
// returns 0 on success and -1 on failure
s8 init_mt(void);

// initializes the gps card
s8 init_gps(void);

// starts the i2c driver
s8 ccard_init_i2c(void);


// cleans up data for the DSAs and turns off power
void cleanup_dsa(void);

// clenas up data for the magnetoruqers and safely switches them off
void cleanup_mt(void);

// cleansup gps data and shuts the device off
void cleanup_gps(void);

// ends the i2c driver
void ccard_cleanup_i2c(void);

// provides a mechanism to restrict i2c bus usage
int ccard_lock_bus(void);
void ccard_unlock_bus(void);

// allows runtime configurable timeout duration
void set_usr_rel_timeout(u8 desired_timeout);
void set_usr_dep_timeout(u8 desired_timeout);


// this function returns an enum value representing the current state of
//   DSA <dsaNumber>
enum dsa_state get_dsa_state(u8 dsa);

// this function returns an enum value representing the current state of
//   magnetorquer <mtNumber>
enum mt_state get_mt_state(u8 mt);

// gets the current GPS location
struct ccard_vec3int ccard_get_position(void);


// as it implies, this function attempts to set DSA <dsaNumber> to
//   the state indicated by <desiredState>
// if that fails because of a hardware issue, i2c access problem,
//   or because <desiredState> indicated an impossible transition
//   (such as transitioning from released to stowed, which must be
//   done manually, or asking to transition to releasing or deploying,
//   which are intermediates and do not represent a discrete state),
//   then this function will halt and return -1, indicating
//   an error
// however, you'll notice that a transition from stowed to released is
//   not recognized as an impossible transition
// so what happens when you indicated a transition from stowed to released?
// well the function will recognize it as a possible error, and will
//   log a warning, as well as return 3, indicating a warning condition,
//   but the operation will still be carried out
// if an operation is acceptable and no warnings or errors occured, this
//   will return 0 to indicate a good value for desiredState
// NOTE: this DOES NOT mean that the DSA state was actually changed, just
//   that it was valid input and has been passed to a background thread
//   to execute the actual hardware change
// Normally, I would add a function pointer as an input to be called when the
//   operation finishes, but because this is a kernel module, not only
//   would that be insecure, it would also lead to insanely difficult bugs
//   to diagnose and crazy reboots, so the recommended way to check the DSA
//   state is to query the getDSAState(dsaNumber) function periodically
//
// desired state should be either <released> or <deployed>
s8 set_dsa_state(u8 dsa, enum dsa_state desired_state);

// this function sets magnetorquer <mtNumber> to the desired state indicated
//   by <desiredState>
// returns 0 if the passed in state was acceptable (which it will always be if
//   you use a value from the MTState enum} and the system has successfully
//   transitioned to that state
// this function, unlike setDSAState, executes hardware changes on a the calling
//   thread, so it does not requires the user to query getMagnetorquer state,
//   though this function will take a longer period of time to return,
//   unlike the DSA function
// <transitioning> is an acceptable state here as it is useful when debugging
//   the hardware, though it is unnecessary to do in normal operation as the
//   implementation already handles switching to that as an intermediate state
// setting the state to transitioning allows for a store magnetic field to
//   discharge as it created a closed, short circuit across the 9.1ohm resistor,
//   the magnetorquer coil, and an isolated branch of the H-bridge IC
s8 set_mt_state(u8 mt, enum mt_state desired_state);


#endif

















