// c card driver header
// yes, the spi and uart devices are unimplemented
// I didn't realize the atmel driver controls them currently
// however, with the move to usb on IRVINE03, it may be necessary to finish
//   the implementation
//
// by Mark Hill

#include<linux/types.h>
#include<linux/i2c.h>
#include<linux/fs.h>
#include<linux/device.h>

#ifndef _cleanheader
#define _cleanheader

// enum for values representing the DSA (deployable solar array) state
enum dsa_state {
	stowed = 0b0000,    // 0

	// values that could be returned by getDSAState but should
	//   not be used in setDSAState
	releasing = 0b0001, // 1
	deploying = 0b0100, // 4

	// acceptable values to use with setDSAState
	released = 0b0010,  // 2
	deployed = 0b1010,  // 10
};


// the magnetorquer circuit was designed around this H-Bridge
//   IC (integrated circuit)(for more information on what an
//     H-Bridge is, see this wikipedia article: https://en.wikipedia.org/wiki/H_bridge)
//   http://www.rohm.com/web/global/datasheet/BD6230F/bd623x-e - IC datasheet
// the advantage of using this H-Bridge IC is that it allows the
//   direction of current through the magnetoruqers to be reversed,
//   which in turn reverses the polarity of the magnetic field generated
//   by the magnetorquer
// however, when dealing with an inductor, you have to be concerned with
//   the back emf generated by a change in current
// when you switch from off to on, on to off, or especially when you
//   change directions, you create a large back emf
// in order to prevent a large voltage damaging the circuitry, the magnetorquer
//   function calls will put the device in a transistioning state when switching
//   from on to off or from reverse to forward, which effectively isolates the
//   magnetorquer circuit into a loop separate from the rest of the circuits so
//   that the magnetic field can decay and release its energy as heat through
//   the 9.1ohm resistor and wire

// enum for values representing the magnetorquer state
enum mt_state {
	off = 0b00,          // 0
	forward = 0b01,      // 1
	reverse = 0b10,      // 2

	// this will automatically be set by the internal implementation
	//   when switching states, so you shouldn't need to set this
	//   condition manually
	// however, setMagnetorquer state won't complain if you pass this
	//   in as a value, as it could be useful for debugging the hardware
	transitioning = 0b11 // 3
};

// structure representing a 3d vector with integer components
struct ccard_vec3int {
	s32 x;
	s32 y;
	s32 z;
};


// 1 = on, 0 = off
// flags: 0 = normal, !0 = emergency shutoff (ignore semaphore)
// the dsas are the only users of the 3v3 source
void set_dsa_pwr(u8 state, s8 flags);
// the main 5v0 source for all components
void set_5v0_pwr(u8 state, s8 flags);

// returns a struct pointer containing the i2c infomation for the GPIO
//   expanders
// these are implemented by their respective controllers
struct i2c_client *dsa_expdr(void);
struct i2c_client *mt_expdr(void);
// returns a struct pointer to the thruster spi_device
struct spi_device *thruster(void);
// returns a struct pointer to the gps device
struct device *gps(void);
// returns a struct pointer to the LED device
struct device *led(void);

// returns a pointer to the navigation class object, which the magnetorquers, GPS,
//   and thruster belong to
// will return NULL if the class doesn't exist or couldn't be created
struct class *ccard_nav_class(void);


//
// devices
//

// this function initializes the DSA hardware so that it is ready for release
//   and/or deploy operations
// returns 0 on success and -1 on failure
s8 init_dsa(void);

// this function initializes the magnetorquer hardware so that it is ready
// for forward or reverse operations
// returns 0 on success and -1 on failure
s8 init_mt(void);

// initializes the gps card
s8 init_gps(void);

// initializes the thruster
s8 init_thruster(void);

//
// drivers
//

// starts the i2c driver
s8 ccard_init_i2c(void);

// starts the spi driver
s8 ccard_init_spi(void);



// cleans up data for the DSAs and turns off power
void cleanup_dsa(void);

// cleans up data for the magnetoruqers and safely switches them off
void cleanup_mt(void);

// cleans up gps data and shuts the device off
void cleanup_gps(void);

// cleans up the thruster data
void cleanup_thruster(void);

// ends the i2c driver
void ccard_cleanup_i2c(void);

// ends the spi driver
void ccard_cleanup_spi(void);

// provides a mechanism to restrict i2c bus usage
int ccard_lock_bus(void);
void ccard_unlock_bus(void);

// gets the dsa state of dsa 'dsa'
enum dsa_state get_dsa_state(u8 dsa);
// gets the magnetorquer state of magnetorquer 'mt'
enum mt_state get_mt_state(u8 mt);

// sets the dsa state to the desired state
s8 set_dsa_state(u8 dsa, enum dsa_state desired_state);
// sets the magnetorquer state to the desired state
s8 set_mt_state(u8 mt, enum mt_state desired_state);




#endif














